//============================================================================================================
//
//
//                  Copyright (c) 2024, Qualcomm Innovation Center, Inc. All rights reserved.
//                              SPDX-License-Identifier: BSD-3-Clause
//
//============================================================================================================
#pragma kernel convert
#pragma kernel activate
#pragma kernel upscale

#define EPSILON 1.19e-07f
#define SEPARATION 1.37e-05f
#define TOLERANCE 1.0e-05f

SamplerState       pointClampSampler : register(s0);
Texture2D<half4>   Conifer_Upscaler_History;
RWTexture2D<half4> Conifer_Upscaler_NextHistory;
Texture2D<half4>   Conifer_Upscaler_MotionDepthAlphaBuffer;
RWTexture2D<half4> Conifer_Upscaler_MotionDepthAlphaBufferSink;
Texture2D<uint>    Conifer_Upscaler_Luma;
RWTexture2D<uint> Conifer_Upscaler_LumaSink;
Texture2D<uint>   Conifer_Upscaler_LumaHistory;
RWTexture2D<uint> Conifer_Upscaler_LumaNextHistory;
RWTexture2D<half4> Conifer_Upscaler_OutputSink;
Texture2D<float>   _CameraDepthTexture;
Texture2D<half2>   _CameraMotionVectorsTexture;
Texture2D<half4>   _MainTex;
Texture2D<half3>   _CameraOpaqueTexture;

float2 Conifer_Upscaler_RenderSize;
float2 Conifer_Upscaler_RenderSizeRcp;
float2 Conifer_Upscaler_OutputSize;
float2 Conifer_Upscaler_OutputSizeRcp;
float2 Conifer_Upscaler_JitterOffset;
float2 Conifer_Upscaler_ScaleRatio;
float  Conifer_Upscaler_CameraFovAngleHor;
float  Conifer_Upscaler_Reset;
half   Conifer_Upscaler_PreExposure;

[numthreads(8, 8, 1)]
void convert(uint3 id : SV_DispatchThreadID) {
    float2 gatherCoord = id.xy * Conifer_Upscaler_RenderSizeRcp.xy;

    half2 motion = _CameraMotionVectorsTexture.SampleLevel(pointClampSampler, gatherCoord, 0);

    int2   InputPosBtmRight = int2(1, 1) + int2(id.xy);
    float  NearestZ         = _CameraDepthTexture.Load(int3(InputPosBtmRight, 0)).x;
    float4 topleft          = _CameraDepthTexture.Gather(pointClampSampler, gatherCoord);
    NearestZ                = min(topleft.w, min(topleft.z, min(topleft.y, min(topleft.x, NearestZ))));

    float2 topRight = _CameraDepthTexture.Gather(pointClampSampler, gatherCoord + float2(Conifer_Upscaler_RenderSizeRcp.x, 0.0)).yz;
    NearestZ        = min(topRight.y, min(topRight.x, NearestZ));

    float2 bottomLeft = _CameraDepthTexture.Gather(pointClampSampler, gatherCoord + float2(0.0, Conifer_Upscaler_RenderSizeRcp.y)).xy;
    NearestZ          = min(bottomLeft.y, min(bottomLeft.x, NearestZ));

    half3 Colorrgb = _MainTex.Load(int3(id.xy, 0)).xyz;

    float val = max(max(Colorrgb.x, Colorrgb.y), Colorrgb.z) + Conifer_Upscaler_PreExposure;
    Colorrgb /= float3(val, val, val);

    float3 Colorycocg;
    Colorycocg.x = 0.25 * (Colorrgb.x + 2.0 * Colorrgb.y + Colorrgb.z);
    Colorycocg.y = clamp(0.5 * Colorrgb.x + 0.5 - 0.5 * Colorrgb.z, 0.0, 1.0);
    Colorycocg.z = clamp(Colorycocg.x + Colorycocg.y - Colorrgb.x, 0.0, 1.0);

    uint x11 = uint(Colorycocg.x * 2047.5);
    uint y11 = uint(Colorycocg.y * 2047.5);
    uint z10 = uint(Colorycocg.z * 1023.5);

    half3 Colorprergb = _CameraOpaqueTexture.Load(int3(id.xy, 0)).xyz;
    Colorprergb /= max(max(Colorprergb.x, Colorprergb.y), Colorprergb.z) + Conifer_Upscaler_PreExposure;
    half3 delta                   = abs(Colorrgb - Colorprergb);
    Conifer_Upscaler_MotionDepthAlphaBufferSink[id.xy] = float4(motion, NearestZ, 350 * max(delta.x, max(delta.y, delta.z)));
    Conifer_Upscaler_LumaSink[id.xy]                   = x11 << 21u | y11 << 10u | z10;
}

[numthreads(8, 8, 1)]
void activate(uint3 id : SV_DispatchThreadID) {
    int2   sampleOffset[4] = {int2(-1, -1), int2(-1, +0), int2(+0, -1), int2(+0, +0)};
    float2 ViewportUV      = (float2(id.xy) + float2(0.5, 0.5)) * Conifer_Upscaler_RenderSizeRcp;
    float2 gatherCoord     = ViewportUV + 0.5f * Conifer_Upscaler_RenderSizeRcp;
    float  luma_reference  = (Conifer_Upscaler_Luma.Gather(pointClampSampler, gatherCoord).w >> 21u) * (1.0 / 2047.5);

    float4 mda = Conifer_Upscaler_MotionDepthAlphaBuffer.Load(int3(id.xy, 0)).xyzw;

    float2 PrevUV    = mda.xy + ViewportUV;
    float  depthclip = 0.0;

    if (mda.z < 1.0 - TOLERANCE) {
        float2 Prevf_sample     = PrevUV * float2(Conifer_Upscaler_OutputSize) - 0.5f;
        float2 Prevfrac         = Prevf_sample - floor(Prevf_sample);
        float  OneMinusPrevfacx = 1.0 - Prevfrac.x;

        float4 Bilinweights = float4(OneMinusPrevfacx - OneMinusPrevfacx * Prevfrac.y, Prevfrac.x - Prevfrac.x * Prevfrac.y, OneMinusPrevfacx * Prevfrac.y, Prevfrac.x * Prevfrac.y);

        float diagonal_length    = length(float2(Conifer_Upscaler_OutputSize));
        float Wdepth             = 0.0;
        float Kfov               = Conifer_Upscaler_CameraFovAngleHor;
        float Ksep_Kfov_diagonal = SEPARATION * Kfov * diagonal_length;
        for (int index = 0; index < 4; index += 2) {
            float4 gPrevdepth = Conifer_Upscaler_MotionDepthAlphaBuffer.Gather(pointClampSampler, PrevUV, sampleOffset[index]);
            float  tdepth1    = min(gPrevdepth.x, gPrevdepth.y);
            float  tdepth2    = min(gPrevdepth.z, gPrevdepth.w);
            float  fPrevdepth = min(tdepth1, tdepth2);

            float Depthsep = Ksep_Kfov_diagonal * (1.0 - min(fPrevdepth, mda.z));
            float weight   = Bilinweights[index];
            Wdepth += clamp(Depthsep / (abs(fPrevdepth - mda.z) + EPSILON), 0.0, 1.0) * weight;

            float2 gPrevdepth2 = Conifer_Upscaler_MotionDepthAlphaBuffer.Gather(pointClampSampler, PrevUV, sampleOffset[index + 1]).zw;
            fPrevdepth         = min(min(gPrevdepth2.x, gPrevdepth2.y), tdepth2);
            Depthsep           = Ksep_Kfov_diagonal * (1.0 - min(fPrevdepth, mda.z));
            weight             = Bilinweights[index + 1];
            Wdepth += clamp(Depthsep / (abs(fPrevdepth - mda.z) + EPSILON), 0.0, 1.0) * weight;
        }
        depthclip = clamp(1.0f - Wdepth, 0.0, 1.0);
    }

    half2  prev_luma_diff = Conifer_Upscaler_LumaHistory.Gather(pointClampSampler, PrevUV).w;
    float  luma_diff      = luma_reference - prev_luma_diff.x;
    float2 current_luma_diff;
    if (!(all(PrevUV >= float2(0, 0)) && all(PrevUV <= float2(1, 1)) && depthclip + Conifer_Upscaler_Reset < 0.1)) {
        current_luma_diff.x = 0.0;
        current_luma_diff.y = 0.0;
    } else {
        current_luma_diff.x = luma_reference;
        current_luma_diff.y = prev_luma_diff.y != 0.0f ? (sign(luma_diff) == sign(prev_luma_diff.y) ? sign(luma_diff) * min(abs(prev_luma_diff.y), abs(luma_diff)) : prev_luma_diff.y) : luma_diff;
    }

    mda.w                                              = floor(mda.w) + 0.5f * (current_luma_diff.x != 0.0f && abs(current_luma_diff.y) != abs(luma_diff));
    Conifer_Upscaler_LumaNextHistory[id.xy]            = current_luma_diff.x;
    Conifer_Upscaler_MotionDepthAlphaBufferSink[id.xy] = half4(mda.xy, depthclip, mda.w);
}

float FastLanczos(float base) {
    float y      = base - 1.0f;
    float y2     = y * y;
    float y_temp = 0.75f * y + y2;
    return y_temp * y2;
}

float3 DecodeColor(uint sample32) {
    uint x11 = sample32 >> 21u;
    uint y11 = sample32 & 2047u << 10u;
    uint z10 = sample32 & 1023u;
    return float3(float(x11) * (1.0 / 2047.5), float(y11) * 4.76953602e-7 - 0.5, float(z10) * (1.0 / 1023.5) - 0.5);
}

[numthreads(8, 8, 1)]
void upscale(uint3 id : SV_DispatchThreadID) {
    float Biasmax_viewportXScale = min(float(Conifer_Upscaler_OutputSize.x) / float(Conifer_Upscaler_RenderSize.x), 1.99);  //Biasmax_viewportXScale
    float scalefactor = min(20.0, pow((float(Conifer_Upscaler_OutputSize.x) / float(Conifer_Upscaler_RenderSize.x)) * (float(Conifer_Upscaler_OutputSize.y) / float(Conifer_Upscaler_RenderSize.y)), 3.0));
    float2 HistoryInfoViewportSizeInverse = Conifer_Upscaler_OutputSizeRcp;
    float2 HistoryInfoViewportSize = float2(Conifer_Upscaler_OutputSize);
    float2 InputJitter = Conifer_Upscaler_JitterOffset;
    float2 InputInfoViewportSize = float2(Conifer_Upscaler_RenderSize);
    float2 Hruv = (float2(id.xy) + 0.5) * HistoryInfoViewportSizeInverse;
    float2 Jitteruv;
    Jitteruv.x = clamp(Hruv.x + (InputJitter.x * HistoryInfoViewportSizeInverse.x), 0.0, 1.0);
    Jitteruv.y = clamp(Hruv.y + (InputJitter.y * HistoryInfoViewportSizeInverse.y), 0.0, 1.0);

    int2 InputPos = int2(Jitteruv * InputInfoViewportSize);

    //float2 Motion = texelFetch(MotionDepthClipAlphaBuffer, InputPos, 0).xy;
    float alphab = Conifer_Upscaler_MotionDepthAlphaBuffer.Load(int3(InputPos, 0)).w;
    float3 mda = Conifer_Upscaler_MotionDepthAlphaBuffer.SampleLevel(pointClampSampler, Jitteruv, 0.0).xyz;
    float2 Motion = mda.xy;

    ///ScreenPosToViewportScale&Bias
    float2 PrevUV = clamp(Hruv - Motion, 0.0, 1.0);
    float depthfactor = mda.z;
    float history_value = frac(alphab); // clamp(alpha, 0.0f, 1.0f);
    float alphamask = (alphab - history_value) * 0.001f;
    history_value *= 2.0;

    float4 History = Conifer_Upscaler_History.SampleLevel(pointClampSampler, PrevUV, 0.0);
    float3 HistoryColor = History.xyz;
    float Historyw = History.w;
    float Wfactor = max(clamp(abs(Historyw), 0.0, 1.0), alphamask);

    /////upsample and compute box
    float4 Upsampledcw = 0.0;
    float kernelfactor = clamp(Wfactor + float(Conifer_Upscaler_Reset), 0.0, 1.0);
    float biasmax = Biasmax_viewportXScale - Biasmax_viewportXScale * kernelfactor;
    float biasmin = max(1.0f, 0.3 + 0.3 * biasmax);
    float biasfactor = max(0.25f * depthfactor, kernelfactor);
    float kernelbias = lerp(biasmax, biasmin, biasfactor);
    float motion_viewport_len = length(Motion * HistoryInfoViewportSize);
    float curvebias = lerp(-2.0, -3.0, clamp(motion_viewport_len * 0.02, 0.0, 1.0));

    float3 rectboxcenter = 0.0;
    float3 rectboxvar = 0.0;
    float rectboxweight = 0.0;
    float2 srcpos = float2(InputPos) + 0.5 - InputJitter;
    float2 srcOutputPos = Hruv * InputInfoViewportSize;

    kernelbias *= 0.5f;
    float kernelbias2 = kernelbias * kernelbias;
    float2 srcpos_srcOutputPos = srcpos - srcOutputPos;

    int2 InputPosBtmRight = 1 + InputPos;
    float2 gatherCoord = float2(InputPos) * Conifer_Upscaler_RenderSizeRcp;
    uint btmRight = Conifer_Upscaler_Luma.Load(int3(InputPosBtmRight, 0)).x;
    uint4 topleft = Conifer_Upscaler_Luma.Gather(pointClampSampler, gatherCoord);
    uint2 topRight = Conifer_Upscaler_Luma.Gather(pointClampSampler, gatherCoord + float2(Conifer_Upscaler_RenderSizeRcp.x, 0.0)).yz;
    uint2 bottomLeft = Conifer_Upscaler_Luma.Gather(pointClampSampler, gatherCoord + float2(0.0, Conifer_Upscaler_RenderSizeRcp.y)).xy;

    float3 rectboxmin;
    float3 rectboxmax;
    {
        rectboxmin = DecodeColor(btmRight);
        float2 baseoffset = srcpos_srcOutputPos + float2(1.0, 1.0);
        float baseoffset_dot = dot(baseoffset, baseoffset);
        float base = clamp(baseoffset_dot * kernelbias2, 0.0, 1.0);
        float weight = FastLanczos(base);
        Upsampledcw += float4(rectboxmin * weight, weight);
        float boxweight = exp(baseoffset_dot * curvebias);
        rectboxmax = rectboxmin;
        float3 wsample = rectboxmin * boxweight;
        rectboxcenter = wsample;
        rectboxvar = rectboxmin * wsample;
        rectboxweight = boxweight;
    }
    {
        float3 samplecolor = DecodeColor(bottomLeft.x);
        float2 baseoffset = srcpos_srcOutputPos + float2(-1.0, 1.0);
        float baseoffset_dot = dot(baseoffset, baseoffset);
        float base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        float weight = FastLanczos(base);
        Upsampledcw += float4(samplecolor * weight, weight);
        float boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        float3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    {
        float3 samplecolor = DecodeColor(bottomLeft.y);
        float2 baseoffset = srcpos_srcOutputPos + float2(0.0, 1.0);
        float baseoffset_dot = dot(baseoffset, baseoffset);
        float base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        float weight = FastLanczos(base);
        Upsampledcw += float4(samplecolor * weight, weight);
        float boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        float3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    {
        float3 samplecolor = DecodeColor(topRight.x);
        float2 baseoffset = srcpos_srcOutputPos + float2(1.0, 0.0);
        float baseoffset_dot = dot(baseoffset, baseoffset);
        float base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        float weight = FastLanczos(base);
        Upsampledcw += float4(samplecolor * weight, weight);
        float boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        float3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    {
        float3 samplecolor = DecodeColor(topRight.y);
        float2 baseoffset = srcpos_srcOutputPos + float2(1.0, -1.0);
        float baseoffset_dot = dot(baseoffset, baseoffset);
        float base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        float weight = FastLanczos(base);
        Upsampledcw += float4(samplecolor * weight, weight);
        float boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        float3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    {
        float3 samplecolor = DecodeColor(topleft.x);
        float2 baseoffset = srcpos_srcOutputPos + float2(-1.0, 0.0);
        float baseoffset_dot = dot(baseoffset, baseoffset);
        float base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        float weight = FastLanczos(base);
        Upsampledcw += float4(samplecolor * weight, weight);
        float boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        float3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    {
        float3 samplecolor = DecodeColor(topleft.y);
        float2 baseoffset = srcpos_srcOutputPos;
        float baseoffset_dot = dot(baseoffset, baseoffset);
        float base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        float weight = FastLanczos(base);
        Upsampledcw += float4(samplecolor * weight, weight);
        float boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        float3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    {
        float3 samplecolor = DecodeColor(topleft.z);
        float2 baseoffset = srcpos_srcOutputPos + float2(0.0, -1.0);
        float baseoffset_dot = dot(baseoffset, baseoffset);
        float base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        float weight = FastLanczos(base);
        Upsampledcw += float4(samplecolor * weight, weight);
        float boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        float3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }
    {
        float3 samplecolor = DecodeColor(topleft.w);
        float2 baseoffset = srcpos_srcOutputPos + float2(-1.0, -1.0);
        float baseoffset_dot = dot(baseoffset, baseoffset);
        float base = clamp(baseoffset_dot * kernelbias2, 0.0f, 1.0f);
        float weight = FastLanczos(base);
        Upsampledcw += float4(samplecolor * weight, weight);
        float boxweight = exp(baseoffset_dot * curvebias);
        rectboxmin = min(rectboxmin, samplecolor);
        rectboxmax = max(rectboxmax, samplecolor);
        float3 wsample = samplecolor * boxweight;
        rectboxcenter += wsample;
        rectboxvar += (samplecolor * wsample);
        rectboxweight += boxweight;
    }

    rectboxweight = 1.0 / rectboxweight;
    rectboxcenter *= rectboxweight;
    rectboxvar *= rectboxweight;
    rectboxvar = sqrt(abs(rectboxvar - rectboxcenter * rectboxcenter));

    Upsampledcw.xyz =  clamp(Upsampledcw.xyz / Upsampledcw.w, rectboxmin - 0.05, rectboxmax + 0.05);
    Upsampledcw.w = Upsampledcw.w * (1.0f / 3.0f) ;

	float tcontribute = history_value * clamp(rectboxvar.x * 10.0f, 0.0, 1.0);
	float OneMinusWfactor = 1.0f - Wfactor;
	tcontribute = tcontribute * OneMinusWfactor;

    float baseupdate = OneMinusWfactor - OneMinusWfactor * depthfactor;
    baseupdate = min(baseupdate, lerp(baseupdate, Upsampledcw.w *10.0f, clamp(10.0f* motion_viewport_len, 0.0, 1.0)));
    baseupdate = min(baseupdate, lerp(baseupdate, Upsampledcw.w, clamp(motion_viewport_len *0.05f, 0.0, 1.0)));
    float basealpha = baseupdate;

    float boxscale = max(depthfactor, clamp(motion_viewport_len * 0.05f, 0.0, 1.0));
    float boxsize = lerp(scalefactor, 1.0f, boxscale);
    float3 sboxvar = rectboxvar * boxsize;
    float3 boxmin = rectboxcenter - sboxvar;
    float3 boxmax = rectboxcenter + sboxvar;
    rectboxmax = min(rectboxmax, boxmax);
    rectboxmin = max(rectboxmin, boxmin);

    float3 clampedcolor = clamp(HistoryColor, rectboxmin, rectboxmax);
	float lerpcontribution = any(rectboxmin > HistoryColor) || any(HistoryColor > rectboxmax) ? tcontribute : 1.0f;
	lerpcontribution = lerpcontribution - lerpcontribution * sqrt(alphamask);
	HistoryColor = lerp(clampedcolor, HistoryColor, clamp(lerpcontribution, 0.0, 1.0));
    float basemin = min(basealpha, 0.1f);
    basealpha = lerp(basemin, basealpha, clamp(lerpcontribution, 0.0, 1.0));

    ////blend color
    float alphasum = max(EPSILON, basealpha + Upsampledcw.w);
    float alpha = clamp(Upsampledcw.w / alphasum + Conifer_Upscaler_Reset, 0.0, 1.0);
    Upsampledcw.xyz = lerp(HistoryColor, Upsampledcw.xyz, alpha);

    Conifer_Upscaler_NextHistory[id.xy] = float4(Upsampledcw.xyz, Wfactor);

    ////ycocg to grb
    float x_z = Upsampledcw.x - Upsampledcw.z;
    Upsampledcw.xyz = float3(
        x_z + Upsampledcw.y,
        Upsampledcw.x + Upsampledcw.z,
        x_z - Upsampledcw.y);

    float compMax = max(Upsampledcw.x, Upsampledcw.y);
    compMax = max(compMax, Upsampledcw.z);
    float scale = Conifer_Upscaler_PreExposure /  ((1.0f + 1.0f / 65504.0f) - compMax);   //(1.0f + 1.0f / 65504.0f) = 1.000015e+00

    Upsampledcw.xyz = Upsampledcw.xyz * scale;
    Conifer_Upscaler_OutputSink[id.xy] = Upsampledcw;
}